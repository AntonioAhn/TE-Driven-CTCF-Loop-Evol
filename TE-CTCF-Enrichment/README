# Analysis steps for binomial and permutation-based enrichment tests for CTCF binding
# in transposable element families, and for TE insertion age estimation within CTCF-
# binding-enriched TE types.

####
# First step is finding the intersections between CTCF sites
# in each species, and with TEs...

# Copy in data and add unique identifiers to each row.
cp ~/mouseENCODE.new/3D-Prediction/data/ChIP-seq/CTCF/hg19.merged.narrowPeak CTCF.hg19.merged.narrowPeak
cp ~/mouseENCODE.new/3D-Prediction/data/ChIP-seq/CTCF/mm9.merged.narrowPeak CTCF.mm9.merged.narrowPeak
awk 'BEGIN {N=1}; {printf "%s\t%d\t%d\t%d\t%d\t.\t%f\t%f\t%f\t%d\n", $1, $2, $3, N, $5, $7, $8, $9, $10, $11; N++}' CTCF.hg19.merged.narrowPeak > tmp
mv tmp CTCF.hg19.merged.narrowPeak
awk -v N=$(tail -n 1 CTCF.hg19.merged.narrowPeak | awk '{print $4}') 'BEGIN {N++}; {printf "%s\t%d\t%d\t%d\t%d\t.\t%f\t%f\t%f\t%d\n", $1, $2, $3, N, $5, $7, $8, $9, $10, $11; N++}' CTCF.mm9.merged.narrowPeak > tmp
mv tmp CTCF.mm9.merged.narrowPeak

# Cross-map CTCF peaks with bnMapper. The version used has been modified from the
# original, and is available at https://github.com/Boyle-Lab/bx-python.
# liftOver chains were prepared as described in ../data/liftover/README.
# Mouse data were mapped to human using the set of swapped human to mouse
# chains to come as close as possible to reversible mapping between species.
bnMapper.py CTCF.hg19.merged.narrowPeak ../data/liftover/hg19.mm9.rbest.chain.gz -f BED12 -k > CTCF.hg19.merged.lifted.bed
bnMapper.py CTCF.hg19.merged.narrowPeak ../data/liftover/hg19.mm9.rbest.chain.gz -f BED12 -k > CTCF.hg19.merged.lifted.bed

# Merge mapped peaks with native peaks to get union sets
bedtools merge -i <(cat CTCF.hg19.merged.narrowPeak CTCF.mm9.merged.lifted.bed | awk '{printf "%s\t%d\t%d\t%d\t%d\n", $1, $2, $3, $4, $5}' | bedtools sort) -c 4 -o collapse -delim "," >  CTCF.hg19.mm9.union.bed
bedtools merge -i <(cat CTCF.mm9.merged.narrowPeak CTCF.hg19.merged.lifted.bed | awk '{printf "%s\t%d\t%d\t%d\t%d\n", $1, $2, $3, $4, $5}' | bedtools sort) -c 4 -o collapse -delim "," >  CTCF.mm9.hg19.union.bed

# Label columns to indicate species-specific/shared occupancy
# Human-referenced
bedtools intersect -v -a CTCF.hg19.merged.narrowPeak -b CTCF.mm9.merged.lifted.bed | awk '{printf "%s\t%d\t%d\t%d\t1\t0\n", $1, $2, $3, $4}' > tmp
bedtools intersect -v -b CTCF.hg19.merged.narrowPeak -a CTCF.mm9.merged.lifted.bed | awk '{printf "%s\t%d\t%d\t%d\t0\t1\n", $1, $2, $3, $4}' >> tmp
bedtools intersect -v -a CTCF.hg19.mm9.union.bed -b tmp | awk '{printf "%s\t%d\t%d\t%d\t1\t1\n", $1, $2, $3, $4}' > tmp2
cat tmp tmp2 > CTCF.hg19.mm9.union.labelled.bed
# Mouse-referenced
bedtools intersect -v -a CTCF.mm9.merged.narrowPeak -b CTCF.hg19.merged.lifted.bed | awk '{printf "%s\t%d\t%d\t%d\t1\t0\n", $1, $2, $3, $4}' > tmp
bedtools intersect -v -b CTCF.mm9.merged.narrowPeak -a CTCF.hg19.merged.lifted.bed | awk '{printf "%s\t%d\t%d\t%d\t0\t1\n", $1, $2, $3, $4}' >> tmp
bedtools intersect -v -a CTCF.mm9.hg19.union.bed -b tmp | awk '{printf "%s\t%d\t%d\t%d\t1\t1\n", $1, $2, $3, $4}' > tmp2
cat tmp tmp2 > CTCF.mm9.hg19.union.labelled.bed

# Intersect with transposable elements
# Human-referenced
bedtools intersect -a <(awk '{printf "%s\t%d\t%d\t%d\t%d\t%d\n", $1, (($2+$3)/2)-50, (($2+$3)/2)+50, $4, $5, $6}' CTCF.hg19.mm9.union.labelled.bed) -b <(zcat /data/adadiehl/repeatMasker/hg19.rmsk.bed.gz | grep -v "random" | grep -v "hap" | grep -v "Un" | grep -v "chrM" | awk 'BEGIN {i=1}; {split($4, A, "."); if (A[2] != "Low_complexity" && A[2] != "Satellite" && A[2] != "Simple_repeat" && A[2] != "tRNA" && A[2] != "rRNA" && A[2] != "scRNA" && A[2] != "snRNA" && A[2] != "srpRNA") {printf "%s\t%d\t%d\t%s\t%s\t%s\t%f\thg19\n", $1, $2, $3, A[1], A[2], A[3], $5; i++}}') -wa -u > tmp
bedtools intersect -v -a CTCF.hg19.mm9.union.labelled.bed -b tmp | awk '{printf "%s\t0\n", $0}' > tmp2
bedtools intersect -a CTCF.hg19.mm9.union.labelled.bed -b tmp -wa -u | awk '{printf "%s\t1\n", $0}' >> tmp2
mv tmp2 CTCF.hg19.mm9.union.labelled.te.bed
# Mouse-referenced
bedtools intersect -a <(awk '{printf "%s\t%d\t%d\t%d\t%d\t%d\n", $1, (($2+$3)/2)-50, (($2+$3)/2)+50, $4, $5, $6}' CTCF.mm9.hg19.union.labelled.bed) -b <(zcat /data/adadiehl/repeatMasker/mm9.rmsk.bed.gz | grep -v "random" | grep -v "hap" | grep -v "Un" | grep -v "chrM" | awk 'BEGIN {i=1}; {split($4, A, "."); if (A[2] != "Low_complexity" && A[2] != "Satellite" && A[2] != "Simple_repeat" && A[2] != "tRNA" && A[2] != "rRNA" && A[2] != "scRNA" && A[2] != "snRNA" && A[2] != "srpRNA") {printf "%s\t%d\t%d\t%s\t%s\t%s\t%f\thg19\n", $1, $2, $3, A[1], A[2], A[3], $5; i++}}') -wa -u > tmp
bedtools intersect -v -a CTCF.mm9.hg19.union.labelled.bed -b tmp | awk '{printf "%s\t0\n", $0}' > tmp2
bedtools intersect -a CTCF.mm9.hg19.union.labelled.bed -b tmp -wa -u | awk '{printf "%s\t1\n", $0}' >> tmp2
mv tmp2 CTCF.mm9.hg19.union.labelled.te.bed

# Add back unmapped features.

# Human-referenced
# Step 1: prepare a minimal data frame
awk '{printf "%s\t%d\t%d\t%d\n", $1, $2, $3, $4}' CTCF.mm9.merged.narrowPeak > tmp1
awk '{printf "%s\t%d\t%d\t%d\n", $1, $2, $3, $4}' CTCF.mm9.merged.lifted.bed > tmp2
# Step 2 is in R. See get_species-specfic_sites.R  -- output is written to tmp3
# Step 3 is back on the command line: Intersect with transposable elements.
bedtools intersect -a <(awk '{printf "%s\t%d\t%d\t%d\t%d\t%d\n", $1, (($2+$3)/2)-50, (($2+$3)/2)+50, $4, $5, $6}' tmp3) -b <(zcat /data/adadiehl/repeatMasker/mm9.rmsk.bed.gz | grep -v "random" | grep -v "hap" | grep -v "Un" | grep -v "chrM" | awk 'BEGIN {i=1}; {split($4, A, "."); if (A[2] != "Low_complexity" && A[2] != "Satellite" && A[2] != "Simple_repeat" && A[2] != "tRNA" && A[2] != "rRNA" && A[2] != "scRNA" && A[2] != "snRNA" && A[2] != "srpRNA") {printf "%s\t%d\t%d\t%s\t%s\t%s\t%f\thg19\n", $1, $2, $3, A[1], A[2], A[3], $5; i++}}') -wa -u > tmp
# Step 4: Label rows in tmp (mouse binding data) with TE overlap labels (tmp and tmp3 already have species occupancy labels) 
bedtools intersect -v -a tmp3 -b tmp | awk '{printf "%s\t0\n", $0}' > tmp2
bedtools intersect -a tmp3 -b tmp -wa -u | awk '{printf "%s\t1\n", $0}' >> tmp2
# Step 5: Combine all outputs into complete data table and remove intermediates.
cat CTCF.hg19.mm9.union.labelled.te.bed tmp2 > tmp
mv tmp CTCF.hg19.mm9.union.labelled.te.bed
rm tmp*

# Mouse-referenced
# Step 1
awk '{printf "%s\t%d\t%d\t%d\n", $1, $2, $3, $4}' CTCF.hg19.merged.narrowPeak > tmp1
awk '{printf "%s\t%d\t%d\t%d\n", $1, $2, $3, $4}' CTCF.hg19.merged.lifted.bed > tmp2
# Step 2, as above: Run commands in get_species-specfic_sites.R
# Step 3
bedtools intersect -a <(awk '{printf "%s\t%d\t%d\t%d\t%d\t%d\n", $1, (($2+$3)/2)-50, (($2+$3)/2)+50, $4, $5, $6}' tmp3) -b <(zcat /data/adadiehl/repeatMasker/hg19.rmsk.bed.gz | grep -v "random" | grep -v "hap" | grep -v "Un" | grep -v "chrM" | awk 'BEGIN {i=1}; {split($4, A, "."); if (A[2] != "Low_complexity" && A[2] != "Satellite" && A[2] != "Simple_repeat" && A[2] != "tRNA" && A[2] != "rRNA" && A[2] != "scRNA" && A[2] != "snRNA" && A[2] != "srpRNA") {printf "%s\t%d\t%d\t%s\t%s\t%s\t%f\thg19\n", $1, $2, $3, A[1], A[2], A[3], $5; i++}}') -wa -u > tmp
# Step 4
bedtools intersect -v -a tmp3 -b tmp | awk '{printf "%s\t0\n", $0}' > tmp2
bedtools intersect -a tmp3 -b tmp -wa -u | awk '{printf "%s\t1\n", $0}' >> tmp2
# Step 5
cat CTCF.mm9.hg19.union.labelled.te.bed tmp2 > tmp
mv tmp CTCF.mm9.hg19.union.labelled.te.bed
rm tmp*

# Plot the Venn diagram -- commands are in plot_orthology-te_data.R.
# Manual adjustments to plot areas to make areas proportional to subset size were
# performed by hand in Adobe Illustrator to produce the final plot presented in Figre 1A.


####
# Second step is performed on the hadoop cluster...

# Find the intersection between CTCF binding sites
# and TE insertions in each cell type using a hive query.
# Commands are in ctcf_te_overlaps.q.

# Combine the resulting data files...
hdfs dfs -cat ctcf_te_enrichment/* > ctcf_te_intersection.all.txt

####
# Remaining analysis steps are in R.
#
# shared.R has commands for reading in the data tables used
# by both binomial and permutation tests.
#
# binomial_tests.R has commands for performing the binomial enrichment tests.
#
# permutation_tests.R has commands for performing the permutation-based enrichment tests.

####
# Age estimation (entire analysis in R) steps are in estimate_te_ages.R
# These results are presented in Figure 1E.

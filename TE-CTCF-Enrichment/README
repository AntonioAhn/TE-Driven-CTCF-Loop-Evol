# Analysis steps for binomial and permutation-based enrichment tests for CTCF binding
# in transposable element families, and for TE insertion age estimation within CTCF-
# binding-enriched TE types.

####
# First step is finding the intersections between CTCF sites
# in each species, and with TEs...

# Copy in data and add unique identifiers to each row.
cp ../data/ChIP-seq/CTCF/hg19.merged.narrowPeak ../data/ChIP-seq/CTCF/mm9.merged.narrowPeak .
awk 'BEGIN {N=1}; {printf "%s\t%d\t%d\t%d\t%d\t.\t%f\t%f\t%f\t%d\n", $1, $2, $3, N, $5, $7, $8, $9, $10, $11; N++}' CTCF.hg19.merged.narrowPeak > tmp
mv tmp CTCF.hg19.merged.narrowPeak
awk -v N=$(tail -n 1 CTCF.hg19.merged.narrowPeak | awk '{print $4}') 'BEGIN {N++}; {printf "%s\t%d\t%d\t%d\t%d\t.\t%f\t%f\t%f\t%d\n", $1, $2, $3, N, $5, $7, $8, $9, $10, $11; N++}' CTCF.mm9.merged.narrowPeak > tmp
mv tmp CTCF.mm9.merged.narrowPeak

# Cross-map CTCF peaks with bnMapper. The version used has been modified from the
# original, and is available at https://github.com/Boyle-Lab/bx-python.
# liftOver chains were prepared as described in ../data/liftover/README.
# Mouse data were mapped to human using the set of swapped human to mouse
# chains to come as close as possible to reversible mapping between species.
bnMapper.py CTCF.hg19.merged.narrowPeak ../data/liftover/hg19.mm9.rbest.chain.gz -f narrowPeak -k -i narrowPeak > CTCF.hg19.merged.lifted.bed
bnMapper.py CTCF.hg19.merged.narrowPeak ../data/liftover/hg19.mm9.rbest.chain.gz -f narrowPeak -k -i narrowPeak > CTCF.hg19.merged.lifted.bed

# Merge mapped peaks with native peaks to get union sets
bedtools merge -i <(cat CTCF.hg19.merged.narrowPeak CTCF.mm9.merged.lifted.bed | awk '{printf "%s\t%d\t%d\t%d\t%d\n", $1, $2, $3, $4, $2+$10}' | bedtools sort) -c 4,5 -o collapse -delim ","  | awk '{psum = 0; N=split($5, A, ","); for (i=0; i<=N; i++) {psum += A[i]}; printf "%s\t%d\t%d\t%d\t%d\n", $1, $2, $3, $4, (psum/N)-$2}' >  CTCF.hg19.mm9.union.bed
bedtools merge -i <(cat CTCF.mm9.merged.narrowPeak CTCF.hg19.merged.lifted.bed | awk '{printf "%s\t%d\t%d\t%d\t%d\n", $1, $2, $3, $4, $2+$10}' | bedtools sort) -c 4,5 -o collapse -delim "," | awk '{psum = 0; N=split($5, A, ","); for (i=0; i<=N; i++) {psum += A[i]}; printf "%s\t%d\t%d\t%d\t%d\n", $1, $2, $3, $4, (psum/N)-$2}'  >  CTCF.mm9.hg19.union.bed

# Label columns to indicate species-specific/shared occupancy
# Human-referenced
bedtools intersect -v -a CTCF.hg19.merged.narrowPeak -b CTCF.mm9.merged.lifted.bed | awk '{printf "%s\t%d\t%d\t%d\t%d\t1\t0\n", $1, $2, $3, $4, $10}' > tmp
bedtools intersect -v -b CTCF.hg19.merged.narrowPeak -a CTCF.mm9.merged.lifted.bed | awk '{printf "%s\t%d\t%d\t%d\t%d\t0\t1\n", $1, $2, $3, $4, $10}' >> tmp
bedtools intersect -v -a CTCF.hg19.mm9.union.bed -b tmp | awk '{printf "%s\t%d\t%d\t%d\t%d\t1\t1\n", $1, $2, $3, $4, $5}' > tmp2
cat tmp tmp2 > CTCF.hg19.mm9.union.labelled.bed
# Mouse-referenced
bedtools intersect -v -a CTCF.mm9.merged.narrowPeak -b CTCF.hg19.merged.lifted.bed | awk '{printf "%s\t%d\t%d\t%d\t%d\t1\t0\n", $1, $2, $3, $4, $10}' > tmp
bedtools intersect -v -b CTCF.mm9.merged.narrowPeak -a CTCF.hg19.merged.lifted.bed | awk '{printf "%s\t%d\t%d\t%d\t%d\t0\t1\n", $1, $2, $3, $4, $10}' >> tmp
bedtools intersect -v -a CTCF.mm9.hg19.union.bed -b tmp | awk '{printf "%s\t%d\t%d\t%d\t%d\t1\t1\n", $1, $2, $3, $4, $5}' > tmp2
cat tmp tmp2 > CTCF.mm9.hg19.union.labelled.bed

# Intersect with transposable elements
# Human-referenced
bedtools intersect -a <(awk '{printf "%s\t%d\t%d\t%d\t%d\t%d\t%d\n", $1, ($2+$5), ($2+$5)+1, $4, $5, $6, $7}' CTCF.hg19.mm9.union.labelled.bed) -b <(zcat ../data/repeatMasker/hg19.rmsk.bed.gz | grep -v "random" | grep -v "hap" | grep -v "Un" | grep -v "chrM" | awk 'BEGIN {i=1}; {split($4, A, "."); if (A[2] != "Low_complexity" && A[2] != "Satellite" && A[2] != "Simple_repeat" && A[2] != "tRNA" && A[2] != "rRNA" && A[2] != "scRNA" && A[2] != "snRNA" && A[2] != "srpRNA") {printf "%s\t%d\t%d\t%s\t%s\t%s\t%f\thg19\n", $1, $2, $3, A[1], A[2], A[3], $5; i++}}') -wa -u > tmp
bedtools intersect -v -a CTCF.hg19.mm9.union.labelled.bed -b tmp | awk '{printf "%s\t0\n", $0}' > tmp2
bedtools intersect -a CTCF.hg19.mm9.union.labelled.bed -b tmp -wa -u | awk '{printf "%s\t1\n", $0}' >> tmp2
mv tmp2 CTCF.hg19.mm9.union.labelled.te.bed
# Mouse-referenced
bedtools intersect -a <(awk '{printf "%s\t%d\t%d\t%d\t%d\t%d\t%d\n", $1, ($2+$5), ($2+$5)+1, $4, $5, $6, $7}' CTCF.mm9.hg19.union.labelled.bed) -b <(zcat ..//data/repeatMasker/mm9.rmsk.bed.gz | grep -v "random" | grep -v "hap" | grep -v "Un" | grep -v "chrM" | awk 'BEGIN {i=1}; {split($4, A, "."); if (A[2] != "Low_complexity" && A[2] != "Satellite" && A[2] != "Simple_repeat" && A[2] != "tRNA" && A[2] != "rRNA" && A[2] != "scRNA" && A[2] != "snRNA" && A[2] != "srpRNA") {printf "%s\t%d\t%d\t%s\t%s\t%s\t%f\thg19\n", $1, $2, $3, A[1], A[2], A[3], $5; i++}}') -wa -u > tmp
bedtools intersect -v -a CTCF.mm9.hg19.union.labelled.bed -b tmp | awk '{printf "%s\t0\n", $0}' > tmp2
bedtools intersect -a CTCF.mm9.hg19.union.labelled.bed -b tmp -wa -u | awk '{printf "%s\t1\n", $0}' >> tmp2
mv tmp2 CTCF.mm9.hg19.union.labelled.te.bed

# Add back unmapped features.
# Human-referenced
# Step 1: prepare a minimal data frame
awk '{printf "%s\t%d\t%d\t%d\t%d\n", $1, $2, $3, $4, $10}' CTCF.mm9.merged.narrowPeak > tmp1
awk '{printf "%s\t%d\t%d\t%d\t%d\n", $1, $2, $3, $4, $10}' CTCF.mm9.merged.lifted.bed > tmp2
# Step 2 is in R. See get_species-specfic_sites.R  -- output is written to tmp3
# Step 3 is back on the command line: Intersect with transposable elements.
bedtools intersect -a <(awk '{printf "%s\t%d\t%d\t%d\t%d\t%d\t%d\n", $1, ($2+$5), ($2+$5)+1, $4, $5, $6, $7}' tmp3) -b <(zcat ../data/repeatMasker/mm9.rmsk.bed.gz | grep -v "random" | grep -v "hap" | grep -v "Un" | grep -v "chrM" | awk 'BEGIN {i=1}; {split($4, A, "."); if (A[2] != "Low_complexity" && A[2] != "Satellite" && A[2] != "Simple_repeat" && A[2] != "tRNA" && A[2] != "rRNA" && A[2] != "scRNA" && A[2] != "snRNA" && A[2] != "srpRNA") {printf "%s\t%d\t%d\t%s\t%s\t%s\t%f\thg19\n", $1, $2, $3, A[1], A[2], A[3], $5; i++}}') -wa -u > tmp
# Step 4: Label rows in tmp (mouse binding data) with TE overlap labels (tmp and tmp3 already have species occupancy labels)
bedtools intersect -v -a tmp3 -b tmp | awk '{printf "%s\t0\n", $0}' > tmp2
bedtools intersect -a tmp3 -b tmp -wa -u | awk '{printf "%s\t1\n", $0}' >> tmp2
# Step 5: Combine all outputs into complete data table and remove intermediates.
cat CTCF.hg19.mm9.union.labelled.te.bed tmp2 > tmp
mv tmp CTCF.hg19.mm9.union.labelled.te.bed
rm tmp*

# Mouse-referenced
# Step 1
awk '{printf "%s\t%d\t%d\t%d\t%d\n", $1, $2, $3, $4, $10}' CTCF.hg19.merged.narrowPeak > tmp1
awk '{printf "%s\t%d\t%d\t%d\t%d\n", $1, $2, $3, $4, $10}' CTCF.hg19.merged.lifted.bed > tmp2
# Step 2, as above: Run commands in get_species-specfic_sites.R
# Step 3
bedtools intersect -a <(awk '{printf "%s\t%d\t%d\t%d\t%d\t%d\t%d\n", $1, ($2+$5), ($2+$5), $4, $5, $6, $7}' tmp3) -b <(zcat ../data/repeatMasker/hg19.rmsk.bed.gz | grep -v "random" | grep -v "hap" | grep -v "Un" | grep -v "chrM" | awk 'BEGIN {i=1}; {split($4, A, "."); if (A[2] != "Low_complexity" && A[2] != "Satellite" && A[2] != "Simple_repeat" && A[2] != "tRNA" && A[2] != "rRNA" && A[2] != "scRNA" && A[2] != "snRNA" && A[2] != "srpRNA") {printf "%s\t%d\t%d\t%s\t%s\t%s\t%f\thg19\n", $1, $2, $3, A[1], A[2], A[3], $5; i++}}') -wa -u > tmp
# Step 4
bedtools intersect -v -a tmp3 -b tmp | awk '{printf "%s\t0\n", $0}' > tmp2
bedtools intersect -a tmp3 -b tmp -wa -u | awk '{printf "%s\t1\n", $0}' >> tmp2
# Step 5
cat CTCF.mm9.hg19.union.labelled.te.bed tmp2 > tmp
mv tmp CTCF.mm9.hg19.union.labelled.te.bed
rm tmp*

# Plot the Venn diagram -- commands are in plot_orthology-te_data.R.
# Manual adjustments to plot areas to make areas proportional to subset size were
# performed by hand in Adobe Illustrator to produce the final plot presented in Figre 1A.


###
# Evolutionary gain/loss of elements and association with TE ages. (Related to Figure 1D)

# Step 1 is to determine whether human and mouse CTCF peaks are orthologous,
# or gained/lost on one of the branches separating the two species using a
# maximum parsimony procedure. To do so, we developed the mapGL utility.
# (https://github.com/adadiehl/mapGL)
# (Branch lengths in the Newick tree are arbitrary, and not used in the algorithm!)
mapGL.py CTCF.hg19.merged.narrowPeak "(((hg19:1,mm9:3):2,(canFam2:4,equCab2:5):6):90,loxAfr3:7)" hg19 mm9 ../data/liftover/hg19.mm9.rbest.chain.gz ../data/liftover/hg19.equCab2.rbest.chain.gz ../data/liftover/hg19.canFam2.rbest.chain.gz ../data/liftover/hg19.loxAfr3.rbest.chain.gz -i narrowPeak > hg19.gain-loss.out
mapGL.py CTCF.mm9.merged.narrowPeak "(((hg19:1,mm9:3):2,(canFam2:4,equCab2:5):6):90,loxAfr3:7)" mm9 hg19 ../data/liftover/mm9.hg19.rbest-rev-hg19.chain.gz ../data/liftover/mm9.equCab2.rbest.chain.gz ../data/liftover/mm9.canFam2.rbest.chain.gz ../data/liftover/mm9.loxAfr3.rbest.chain.gz -i narrowPeak > mm9.gain-loss.out

# Step 2: Add TE intersections
bedtools intersect -a <(awk '{printf "%s\t%d\t%d\t%d\t%d\t%s\n", $1, ($2+$5), ($2+$5)+1, $4, $5, $6}' hg19.gain-loss.out) -b <(zcat ../data/repeatMasker/hg19.rmsk.bed.gz | grep -v "random" | grep -v "hap" | grep -v "Un" | grep -v "chrM" | awk 'BEGIN {i=1}; {split($4, A, "."); if (A[2] != "Low_complexity" && A[2] != "Satellite" && A[2] != "Simple_repeat" && A[2] != "tRNA" && A[2] != "rRNA" && A[2] != "scRNA" && A[2] != "snRNA" && A[2] != "srpRNA") {printf "%s\t%d\t%d\t%s\t%s\t%s\t%f\thg19\n", $1, $2, $3, A[1], A[2], A[3], $5; i++}}') -wo | awk '{printf "%s\t%d\t%d\t%d\t%d\t%s\t1\t%s\t%s\t%s\t%f\thg19\n", $1, $2, $3, $4, $5, $6, $10, $11, $12, $13}' > gain-loss_TE.txt
bedtools intersect -a <(awk '{printf "%s\t%d\t%d\t%d\t%d\t%s\n", $1, ($2+$5), ($2+$5)+1, $4, $5, $6}' mm9.gain-loss.out) -b <(zcat ../data/repeatMasker/mm9.rmsk.bed.gz | grep -v "random" | grep -v "hap" | grep -v "Un" | grep -v "chrM" | awk 'BEGIN {i=1}; {split($4, A, "."); if (A[2] != "Low_complexity" && A[2] != "Satellite" && A[2] != "Simple_repeat" && A[2] != "tRNA" && A[2] != "rRNA" && A[2] != "scRNA" && A[2] != "snRNA" && A[2] != "srpRNA") {printf "%s\t%d\t%d\t%s\t%s\t%s\t%f\tmm9\n", $1, $2, $3, A[1], A[2], A[3], $5; i++}}') -wo | awk '{printf "%s\t%d\t%d\t%d\t%d\t%s\t1\t%s\t%s\t%s\t%f\tmm9\n", $1, $2, $3, $4, $5, $6, $10, $11, $12, $13}' >> gain-loss_TE.txt

# Step 3: Add ages and do the box plot in R. These steps are in plot_gain-loss_age_distributions.R.


####
# Second step is performed on the hadoop cluster...

# Find the intersection between CTCF binding sites
# and TE insertions in each cell type using a hive query.
# Commands are in ctcf_te_overlaps.q.

# Combine the resulting data files...
hdfs dfs -cat ctcf_te_enrichment/* > ctcf_te_intersection.all.txt

####
# Remaining analysis steps are in R.
#
# shared.R has commands for reading in the data tables used
# by both binomial and permutation tests.
#
# binomial_tests.R has commands for performing the binomial enrichment tests.
#
# permutation_tests.R has commands for performing the permutation-based enrichment tests.

####
# Age estimation (entire analysis in R) steps are in estimate_te_ages.R
# These results are presented in Figure 1E.
